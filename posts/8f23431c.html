<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Navimark"><meta name="keywords" content="汇编,汇编入门,寄存器,CPU,lr,pc,sp,x29,x30"><meta name="description" content="开个坑，记录一下系统性地学习 iOS 逆向的过程，从汇编入门开始。在这之前对汇编基础和逆向有一些了解，所以文章只当做查缺补漏，记录本人认为有意思的点——虽然这个“缺”和“漏”有点大😁 以下汇编笔记基于 ARM64 整理，可能不完全适用于基于其他架构  我们写的文本代码，被编译器和链接器按照一定的格式转变成二进制字节流文件，在被操作系统加载执行时，文件又以一条条机器码的形式被映射到内存中，这些机"><meta property="og:type" content="article"><meta property="og:title" content="逆向学习笔记 - ARM64 汇编入门"><meta property="og:url" content="https://navimark.github.io/posts/8f23431c.html"><meta property="og:site_name" content="子非鱼"><meta property="og:description" content="开个坑，记录一下系统性地学习 iOS 逆向的过程，从汇编入门开始。在这之前对汇编基础和逆向有一些了解，所以文章只当做查缺补漏，记录本人认为有意思的点——虽然这个“缺”和“漏”有点大😁 以下汇编笔记基于 ARM64 整理，可能不完全适用于基于其他架构  我们写的文本代码，被编译器和链接器按照一定的格式转变成二进制字节流文件，在被操作系统加载执行时，文件又以一条条机器码的形式被映射到内存中，这些机"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://navimark.github.io/img/PostIndexImg/202103/Assembly-01.png"><meta property="article:published_time" content="2021-03-01T02:03:21.000Z"><meta property="article:modified_time" content="2022-02-23T11:00:40.402Z"><meta property="article:author" content="Navimark"><meta property="article:tag" content="汇编"><meta property="article:tag" content="底层"><meta property="article:tag" content="笔记"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://navimark.github.io/img/PostIndexImg/202103/Assembly-01.png"><title>逆向学习笔记 - ARM64 汇编入门 - 子非鱼</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/xcode.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"navimark.github.io",root:"/",version:"1.8.14",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:6},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:15186363,google:"UA-154660540-1",gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:1278975811,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.0.0"></head><body><header style="height:50vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>子非鱼</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="逆向学习笔记 - ARM64 汇编入门"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-03-01 10:03" pubdate>2021年3月1日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.1k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 35 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">逆向学习笔记 - ARM64 汇编入门</h1><div class="markdown-body"><blockquote><p>开个坑，记录一下系统性地学习 iOS 逆向的过程，从汇编入门开始。在这之前对汇编基础和逆向有一些了解，所以文章只当做查缺补漏，记录本人认为有意思的点——虽然这个“缺”和“漏”有点大😁</p><p>以下汇编笔记基于 ARM64 整理，可能不完全适用于基于其他架构</p></blockquote><p>我们写的文本代码，被编译器和链接器按照一定的格式转变成二进制字节流文件，在被操作系统加载执行时，文件又以一条条机器码的形式被映射到内存中，这些机器码有的可能只是一个数据集，也有的可能是一条汇编指令。对于 CPU 来说这些都不重要，它只关心往数据的读和写</p><h1 id="CPU-和总线"><a href="#CPU-和总线" class="headerlink" title="CPU 和总线"></a>CPU 和总线</h1><p>CPU 上密密麻麻的针脚就是和总线相连的，总线是若干“根”导线的集合，按照功能可以分为地址总线、数据总线和控制总线。计算机（广义的）系统里面的组件由总线连接</p><ul><li><p>地址总线</p><p>内存是按照存储单元划分的，每一个存储单元的大小为 1 B，并且都有编号，即地址，CPU 可以通过地址信息实现对存储单元的定位（寻址），完成内存的读和写操作，这个寻址过程是通过地址总线完成的。如果某一个 CPU 架构有 10 根地址总线，那么它可以寻址的范围为 $2^{10}$ ，可以说这个 CPU 的地址总线的宽度为 10。寻址过程可以类比为 10 个手指头按在键盘上的情形，规定每个指头按下去为 1，抬起为 0，某一次“打字”指头定位到不同的键帽时，就是一次寻址</p><p>ARM64 环境下，实例对象有一个用来指向类对象的指针 <code>isa</code> ，它的值仅有 33 个 bit 用来保存真正的地址，说明 AMR64 的寻找宽度被 iOS 限制为了 33 ，<del>这种模式所能支持的最大内存容量为：$2^{33}$ = $2^{23}$K = $2^{13}$M = $2^3$ G = 8G，目前 iPhone 12 Pro 的最大内存达到了 6GB，随着内存越做越大的趋势，未来 iPhone 的内存要突破 8GB 的限制，<code>isa</code> 的这套策略是不是要修改呢？</del><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里把 CPU 寻找理想化了。33 位的寻找，在 CPU 视角，最大可以查找 $2^{33}$ 个内存单元，每一次查找的对象都是一个字节，所以可以查找的最大内存地址是 $2^{33}$ = 8G Byte，但 CPU 寻址讲究内存对齐，按照 8 Byte 对齐的话，真实可支持的内存空间就是 8*8GB。所以 isa 的这一套还是很稳。
">[1]</span></a></sup></p></li><li><p>数据总线</p><p>CPU 与内存或其他可读写组件之前的数据传送是通过数据总线完成的，数据总线的宽度决定了 CPU 的数据吞吐效率，8 根数据总线一次可以传送 8 位二进制数据，即一个字节</p></li><li><p>控制总线</p><p>CPU 对外部组件的控制是通过控制总线来完成的，控制总线的宽度决定了 CPU 对系统中其他组件的控制能力</p></li></ul><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>寄存器是 CPU 内部可以高速读写的部件，ARM64 CPU 中一共有 34 个，包括 31 个通用寄存器和 3 个程序状态辅助寄存器。对于通用寄存器，如果使用 <code>x0 - x30</code> 即表示访问一个 64 位数，如果使用 <code>w0 - w30</code> 即表示访问这些寄存器的低 32 位。另外还有三个特殊的寄存器：</p><ul><li><code>SP</code>：表示栈顶指针寄存器，里面的值始终指向当前栈帧的顶部</li><li><code>PC</code>：程序计数器，它总是指向要执行的下一条指令。它指向哪里，哪里就会被执行。一段机器码一旦被送入 PC 寄存器，就会被当做汇编指令执行。在 ARM64 中不允许直接更改 PC 寄存器的值</li><li><code>CPSR</code>：程序状态寄存器(current program status register)，包含条件标志位、中断禁止位、当前处理器模式标志和其他的一些控制状态位</li></ul><h1 id="初始汇编"><a href="#初始汇编" class="headerlink" title="初始汇编"></a>初始汇编</h1><h3 id="Xcode-汇编环境"><a href="#Xcode-汇编环境" class="headerlink" title="Xcode 汇编环境"></a>Xcode 汇编环境</h3><p>根据 Xcode 默认模板创建一个 iOS App 工程，在 <code>-[ViewController viewDidLoad]</code> 添加断点，设置 <code>Always Show Disassembly</code>，勾选 <code>All Variables,Registers,Globals and Statics</code>，在 ARM64 真机上运行起来后，进入断点：<br><img src="8f23431c/1.png" srcset="/img/loading.gif" lazyload alt=""></p><ol><li>左侧的箭头 <code>-&gt;</code> 表示即将执行的指令所在地址，也是 pc 的值</li><li>后面一列十六进制数表示编译生成后的二进制代码段映射到虚拟内存后的地址。地址值 = __PAGEZERO.size + ASLR + File.offset</li><li>右边的尖括号 &lt;+$2^{x}$&gt; 表示指令的偏移值，数值表示十进制，字节为单位，可以发现 ARM64 的一条指令大小为 4B</li><li>最后面的就是汇编指令了，从机器码根据一定的规则翻译而来，翻译规则可以查询 ARM 手册</li><li>Debug Area 勾选了 <code>All Variables,Registers,Globals and Statics</code>，所以可以看到寄存器的值。展开 <code>General Purpose Registers</code> 发现 pc 寄存器的值就是箭头指向的值</li></ol><h3 id="汇编程序"><a href="#汇编程序" class="headerlink" title="汇编程序"></a>汇编程序</h3><p>下面将编写一个小程序，通过函数嵌套调用来演示 lr 和 pc 如何相互配合实现栈平衡。在这之前先回顾一下关键的指令和相关寄存器。</p><ul><li>基础指令：<code>str</code>/<code>stp</code>/<code>ldr</code>/<code>ldp</code>，用于寄存器和内存之间的值传递<ul><li><code>str x8, [x9]</code>：中括号表示寻址，<code>str</code> 表示将寄存器数据放入到内存，这句话的意思是把 x8 中的数据存到 x9 所表示的内存地址中</li><li><code>stp x29, x30, [sp, #0x50]</code>：<code>stp</code> 同 <code>str</code> ，但是可以同时操作两个寄存器，这句话表示把 x29 和 x30 的值，依次存入 sp 指向的位置，然后执行 sp = sp + #0x50。按照 iOS 中栈生长方向，x29 在高地址， x30 在低地址</li><li><code>ldr x1, [x8]</code>：将内存数据放入寄存器</li><li><code>ldp x29, x30, [sp, #0x10]</code>：同<code>ldr</code>，但是可以同时操作两个寄存器，表示从 sp 的位置，依次读取两个 8 字节数据，存入 x29 和 x30</li><li><code>ret</code>：return 指令，当前子程序结束后，返回到调用所在行的下一行，其实就是返回到 lr 寄存器记录的地址</li><li><code>bl label</code>：跳转到 label 处执行，同时将下一个指令存入 lr</li><li><code>mov x1, x2</code>：将 x2 的值赋值给 x1，用于寄存器之前传值</li></ul></li><li>关键寄存器 lr：也叫 x30，约定让它来存放函数跳转前的下一条指令的地址，以便在子函数执行完毕后能回到调用它的地方</li></ul><p>汇编程序：有两个函数，函数 A 接收两个形参，调用函数 B 完成相减计算，在 A 中对 B 返回的结果乘以 2 ，最后将结果回传给 A 的调用者。</p><ol><li>在 Xcode 工程添加 asm.s 文件，写入以下内容<figure class="highlight armasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">.text</span><br><span class="hljs-symbol">.global</span> _A, _B<br><br><span class="hljs-symbol">_A:</span><br>    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">sp</span>, <span class="hljs-built_in">sp</span>, <span class="hljs-number">#0x10</span><br>    <span class="hljs-keyword">str</span> x30, [<span class="hljs-built_in">sp</span>]<br>    <span class="hljs-keyword">bl</span> _B<br>    <span class="hljs-keyword">mov</span> x1, <span class="hljs-number">#0x02</span><br>    <span class="hljs-keyword">mul</span> x0, x0, x1<br>    <span class="hljs-keyword">ldr</span> x30, [<span class="hljs-built_in">sp</span>]<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">sp</span>, <span class="hljs-built_in">sp</span>, <span class="hljs-number">#0x10</span><br>    ret<br><span class="hljs-symbol">_B:</span><br>    <span class="hljs-keyword">add</span> x0, x1, x0<br>    ret<br></code></pre></td></tr></table></figure></li><li>在 <code>ViewController.m</code> 中添加如下代码。执行后发现能得到预期结果<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">int</span> B(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b);<br><span class="hljs-keyword">int</span> A(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b);<br>- (<span class="hljs-keyword">void</span>)viewDidLoad <br>&#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <span class="hljs-keyword">int</span> a = A(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;结果:%@&quot;</span>,@(a));<br>    <span class="hljs-comment">// 输出： 结果:10</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>在 <code>int a = A(2,3);</code> 添加断点，运行后如下图，注意 <code>bl</code> 的下一条指令地址为<code>0x102719d84</code>，理论上，此处 <code>bl</code> 语句执行后，lr 寄存器的值就会被设置成 <code>0x102719d84</code><br><img src="8f23431c/2.png" srcset="/img/loading.gif" lazyload alt=""></li><li>按住 Control 键，进入 A 函数，发现 lr 寄存器被正确设置了，这是编译器保证的。现在完全进入了自定义的程序流程，需要自己去关注这些寄存器的变化了。lr 寄存器只有一个，现在 A 中预期需要 <code>bl _B</code>，lr 将被默认设置为<code>0x102719df0</code>，如果不对原 lr 寄存器的值进行保护，那么 B 执行完毕后，lr 寄存器保存的仍然是<code>0x102719df0</code>，A 执行到<code>ret</code> 语句时，会跳转到 lr 处，这样将导致 A 中出现死循环。所以子程序 A 一开始，需要开辟一个栈空间，用来保存它自己的返回地址。<br><img src="8f23431c/3.png" srcset="/img/loading.gif" lazyload alt=""></li><li><code>sub sp, sp, #0x10</code> 表示开辟一个 16 字节大小的栈空间（对栈的操作是以 16 字节对齐的），然后 sp 指向栈顶。iOS 的栈空间是从高地址向低地址生长，所以减操作即表示扩大栈空间。<code>str x30, [sp]</code>表示将 x30 的值存入 sp 指向的空间，sp 指向了栈顶，所以 x30 的存储在 [sp - 0x10, sp] 范围内，即往高地址写</li><li>保护好了 x30 就可以跳转到 B 了，跳转后，lr 被赋值为<code>0x102719df0</code>。A 被调用时两个形参分别放到了 x0 和 x1 中，跳转到 B 后，可以直接对 x0 和 x1 做加法操作，将结果存到 x0 用作返回值，接下来执行<code>ret</code>，跳转到<code>0x102719df0</code>返回到 A<br><img src="8f23431c/4.png" srcset="/img/loading.gif" lazyload alt=""><br><img src="8f23431c/5.png" srcset="/img/loading.gif" lazyload alt=""></li><li><code>mov x1, #0x2</code>将一个立即数 0x2 存入 x1 中，后面的 <code>mul</code> 表示乘法，并将结果放入了 x0 中</li><li>现在返回值已经放到了 x0，是时候返回到调用 A 的地方了。<code>ldr x30, [sp]</code>表示从 sp 指向的地方读取数据存入 x30，此处将原先保存的回调地址给回了 x30。此处肯定是往高地址读，因为低地址不属于当前的栈帧，不能随便读</li><li><code>add sp, sp, #0x10</code>退栈，还回刚刚申请的 16 个字节空间，此时 lr 的寄存器应该是<code>0x102719d84</code>，执行<code>ret</code>后，就可以返回到调用 A 的地方了<br><img src="8f23431c/6.png" srcset="/img/loading.gif" lazyload alt=""></li><li>开辟栈空间存入 lr、fp 和取出 lr、fp 归还栈空间这两步操作非常套路化，所以有了简化指令，就是在 Xcode 高级语言编译成的汇编代码的界面可以看到的 <code>stp x29, x30, [sp, #0x40]</code> 和 <code>ldp x29, x30, [sp, #0x40]</code></li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ol><li>之前在看反汇编代码时，看到形如 <code>stp x29, x30, [sp, #0x40]</code> 和 <code>ldp x29, x30, [sp, #0x40]</code> 这类指令时非常困惑，而且非常有规律，分别出现在一个子程序的开始和结尾处，自己也查找了一些大佬的博客，有说到是对栈帧进行保护，不过总感觉都说得比较抽象，不在自己的认知范围内，也可能是大佬觉得这是很显而易见的事情懒得多费口舌吧。。。总之还是得自己动手去调试一遍调用流程，才能有更深入的理解</li><li>上述汇编程序，和实现了同样功能的高级语言反汇编出来的有些不一样，这中间涉及到编译器优化，但具体原则不是很清楚</li><li>从理论上说，内存空间是连续的，一个栈结构需要一个 top 指针（sp），当然也需要一个 bottom 指针（fp），而且随着嵌套的深入，每个栈帧都有自己的栈空间，或大或小，必然要知道一个栈帧的实际空间大小。不过目前还没有遇到什么场景要依据 fp 才能进行的，所以对于为什么要保护 fp 理解得还不是很深</li><li>学习汇编还是需要多看代码，尤其是需要对照高级语言来看编译生成的汇编代码</li></ol><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这里把 CPU 寻找理想化了。33 位的寻找，在 CPU 视角，最大可以查找 $2^{33}$ 个内存单元，每一次查找的对象都是一个字节，所以可以查找的最大内存地址是 $2^{33}$ = 8G Byte，但 CPU 寻址讲究内存对齐，按照 8 Byte 对齐的话，真实可支持的内存空间就是 8*8GB。所以 <code>isa</code> 的这一套还是很稳。 <a href="#fnref:1" rev="footnote" class="footnote-backref">↩</a></span></span></li></ol></div></section></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%B1%87%E7%BC%96/">汇编</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a> <a class="hover-with-bg" href="/tags/%E5%BA%95%E5%B1%82/">底层</a> <a class="hover-with-bg" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/posts/9d246b3e.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">逆向学习笔记 - 部分场景的 ARM64 汇编指令</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/f369e18d.html"><span class="hidden-mobile">算法 - 下三角填充（ Swift 学习 & 过渡设计）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",(function(){var i=Object.assign({appId:"wphA3YWunUyu9a9gbGyb9kh1-MdYXbMMI",appKey:"Y6tve5P6QYMvu13i6cXcL8ly",path:"window.location.pathname",placeholder:"说点什么",avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!1,serverURLs:null,emojiCDN:null,emojiMaps:null,enableQQ:!1,appid:"wphA3YWunUyu9a9gbGyb9kh1-MdYXbMMI",appkey:"Y6tve5P6QYMvu13i6cXcL8ly"},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{Fluid.plugins.initFancyBox("#valine .vcontent img:not(.vemoji)")})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><span id="cnzz_stat_icon_1278975811" style="display:none"></span></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/local-search.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},loader:{},options:{renderActions:{findScript:[10,e=>{document.querySelectorAll('script[type^="math/tex"]').forEach(t=>{const n=!!t.type.match(/; *mode=display/),o=new e.options.MathItem(t.textContent,e.inputJax[0],n),a=document.createTextNode("");t.parentNode.replaceChild(a,t),o.start={node:a,delim:"",n:0},o.end={node:a,delim:"",n:0},e.math.push(o)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}}</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js"></script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?15186363";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script defer>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-154660540-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script defer src="//s4.cnzz.com/z_stat.php?id=1278975811&show=pic" type="text/javascript"></script><script src="/js/boot.js"></script></body></html>