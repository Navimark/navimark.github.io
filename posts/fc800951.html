<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Navimark"><meta name="keywords" content="load,hook,initialize"><meta name="description" content="我们的程序编译成二进制后，在启动时需要初始化运行环境，包括类环境的初始化，涉及到类相关方法的加载，其中很重要的两个方法有 +load 和 +initialize，这两个方法都会在初始化的时候被调用，相信大家都不陌生，但是涉及到底层细节时可能就不太熟悉了，比如它们是如何被调用的？为什么会是这样的调用？它们在写业务代码时能用来做什么？本文将通过 runtime 和 dyld 源码来回答这些问题  官"><meta property="og:type" content="article"><meta property="og:title" content="OC runtime 中的 load 和 initialize"><meta property="og:url" content="https://alphabyte.tk/posts/fc800951.html"><meta property="og:site_name" content="子非鱼"><meta property="og:description" content="我们的程序编译成二进制后，在启动时需要初始化运行环境，包括类环境的初始化，涉及到类相关方法的加载，其中很重要的两个方法有 +load 和 +initialize，这两个方法都会在初始化的时候被调用，相信大家都不陌生，但是涉及到底层细节时可能就不太熟悉了，比如它们是如何被调用的？为什么会是这样的调用？它们在写业务代码时能用来做什么？本文将通过 runtime 和 dyld 源码来回答这些问题  官"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://alphabyte.tk/img/PostIndexImg/202001/load.vs.initialize.png"><meta property="article:published_time" content="2020-09-09T08:25:01.000Z"><meta property="article:modified_time" content="2022-02-23T11:00:40.430Z"><meta property="article:author" content="Navimark"><meta property="article:tag" content="底层"><meta property="article:tag" content="iOS"><meta property="article:tag" content="Runtime"><meta property="article:tag" content="Objective-C"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://alphabyte.tk/img/PostIndexImg/202001/load.vs.initialize.png"><title>OC runtime 中的 load 和 initialize - 子非鱼</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/xcode.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"alphabyte.tk",root:"/",version:"1.8.14",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:6},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:15186363,google:"UA-154660540-1",gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:1278975811,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.0.0"></head><body><header style="height:50vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>子非鱼</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="OC runtime 中的 load 和 initialize"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-09-09 16:25" pubdate>2020年9月9日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 10k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 88 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">OC runtime 中的 load 和 initialize</h1><div class="markdown-body"><blockquote><p>我们的程序编译成二进制后，在启动时需要初始化运行环境，包括类环境的初始化，涉及到类相关方法的加载，其中很重要的两个方法有 <code>+load</code> 和 <code>+initialize</code>，这两个方法都会在初始化的时候被调用，相信大家都不陌生，但是涉及到底层细节时可能就不太熟悉了，比如它们是如何被调用的？为什么会是这样的调用？它们在写业务代码时能用来做什么？本文将通过 <code>runtime</code> 和 <code>dyld</code> 源码来回答这些问题</p></blockquote><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p>遇事不决，官方文档！网上的博客以讹传讹的信息太多，最可靠的资料来源还是得看官方文档。<br>根据文档上的描述，<code>+load</code> 是在 class 或 Category 被添加到 <code>runtime</code> 时调用的，而 <code>+initialize</code> 是在类第一次收到消息时被调用。继续看详情，我们能得到以下印象：</p><ul><li><code>+load</code><ul><li>静态库或动态库中的 load 方法都会被调用，前提是它们实现了 load 方法</li><li>在继承链上依次按照本类、子类、孙子类的顺序调用</li><li>本类上的 load 方法会先于所有分类上的 load 方法调用</li></ul></li><li><code>+initialize</code><ul><li><code>+initialize</code> 方法会在调用第一次该类的方法之前被调用</li><li><code>+initialize</code> 的调用阻塞式的，在 <code>+initialize</code> 方法执行完毕之前，该类的其他任何方法调用都会被阻断（block）</li><li>在继承链上依次按照子类、孙子类的顺序调用</li><li>当继承链上某个类没有 <code>+initialize</code> 的实现，那么其父类的 <code>+initialize</code> 可能会被多次执行</li><li><code>+initialize</code> 在每个类上只会被调用一次</li></ul></li></ul><h1 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h1><p>基于 objc4-818.2 可调试源码<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/LGCooci/objc4_debug/tree/master/objc4-818.2
">[1]</span></a></sup>创建一个<a target="_blank" rel="noopener" href="https://github.com/Navimark/RuntimeLoadInit">四世同堂工程</a>，添加符号断点 <code>+[KFCRootObject initialize]</code> <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="尝试过在 KFCRootObject.m 的 + (void)initialize 处添加断点，但运行时没有进来🤔，知道原因的大佬烦请留言赐教
">[2]</span></a></sup>，选中Scheme: KCObjcBuild，<code>KCObjcBuild</code> target 的 <code>main.m</code> 文件中的 main 函数代码为：<br></p><figure class="highlight objc"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-comment">// insert code here...</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Hello, World!&quot;</span>);<br>        <span class="hljs-built_in">NSObject</span> *objc = [KFCRootObject alloc];<br>        <br>        <span class="hljs-built_in">NSObject</span> *objc1 = [KFCRootObject alloc];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>运行后<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="x86_64 架构运行
">[3]</span></a></sup>方法调用栈：<br><img src="fc800951/1.png" srcset="/img/loading.gif" lazyload alt=""><br>下面按照入栈顺序分析<p></p><h2 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a><code>initialize</code></h2><ol><li><p><code>main</code></p><p><img src="fc800951/3.png" srcset="/img/loading.gif" lazyload alt=""><br><code>0x0000000100008468</code> 是指向类对象的指针，调用 <code>alloc</code> 时，首先被转换成对 <code>objc_alloc</code> 的调用</p></li><li><p><code>objc_alloc</code> -&gt; <code>callAlloc(objc_class*, bool, bool) [inlined]</code></p><p>在 <code>objc_alloc</code> 和 <code>callAlloc(objc_class*, bool, bool) [inlined]</code> 中，对形参、调用环境做了一番校验后，最终调用了 <code>((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</code>，接着进入 <code>objc_msgSend</code> 的汇编实现</p></li><li><code>_objc_msgSend_uncached</code> -&gt; <code>lookUpImpOrForward</code> -&gt; <code>realizeAndInitializeIfNeeded_locked(objc_object*, objc_class*, bool)</code><ul><li>当 <code>@selector(alloc)</code> 对应的 IMP 在方法缓存中不存在时，会调用 <code>MethodTableLookup</code> 继续查找，这部分的汇编代码又将流程导向 <code>lookUpImpOrForward</code>，后者预期返回该 IMP。</li><li><code>lookUpImpOrForward</code> 中调用 <code>realizeAndInitializeIfNeeded_locked(inst, cls, behavior &amp; LOOKUP_INITIALIZE)</code> 时，<code>behavior</code> 形参值为 <code>0x1011</code>，包含标记位 <code>LOOKUP_INITIALIZE</code>，即形参 <code>initialize</code> 为 true<br><img src="fc800951/4.png" srcset="/img/loading.gif" lazyload alt=""></li><li><code>(slowpath(initialize &amp;&amp; !cls-&gt;isInitialized()))</code> 判断当前类是否被初始化过，<code>slowpath(x)</code> 宏定义标记暗示编译器的优化方向，表明 <code>x</code> 较大概率为 <code>false</code>，重点看看<code>!cls-&gt;isInitialized()</code>：<div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="fc800951/5.png" srcset="/img/loading.gif" lazyload alt=""></div><div class="group-image-wrap"><img src="fc800951/6.png" srcset="/img/loading.gif" lazyload alt=""></div></div></div></li><li>从字面意思可以看出当前类是否被初始化的信息保存在元类的 <code>class_rw_t</code> 结构的 <code>flags</code> 标记位中，由于 <code>#define RW_INITIALIZED (1&lt;&lt;29)</code>，所以是否被初始化的信息保存在 <code>flags</code> 的右起第 29 位中</li></ul></li><li><p><code>initializeAndLeaveLocked(objc_class*, objc_object*, mutex_tt&lt;true&gt;&amp;)</code> -&gt; <code>initializeAndMaybeRelock(objc_class*, objc_object*, mutex_tt&lt;true&gt;&amp;, bool)</code> -&gt; <code>initializeNonMetaClass</code></p><p><code>initializeNonMetaClass</code> 中:</p><ul><li><p>如果发现父类没有调用过初始化方法，将递归调用父类的初始化方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objc">supercls = cls-&gt;getSuperclass();<br><span class="hljs-keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;<br>    initializeNonMetaClass(supercls);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过加锁来设置 <code>CLS_INITIALIZING</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc">monitor_locker_t lock(classInitLock);<br><span class="hljs-keyword">if</span> (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;<br>    cls-&gt;setInitializing();<br>    reallyInitialize = <span class="hljs-literal">YES</span>;<br><br>    <span class="hljs-comment">// Grab a copy of the will-initialize funcs with the lock held.</span><br>    localWillInitializeFuncs.initFrom(willInitializeFuncs);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> setInitializing() &#123;<br>    ASSERT(!isMetaClass());<br>    ISA()-&gt;setInfo(RW_INITIALIZING);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接下来标记当前类被当前所在线程独占（当被某一线程独占时，只能在当前线程向类发送消息，其他线程在独占结束之前只能等待），然后向当前类发送 <code>+initialize</code> 消息</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">_setThisThreadIsInitializingClass(cls);<br></code></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> callInitialize(Class cls)<br>&#123;<br>    <span class="hljs-comment">// 通过 objc_msgSend 走消息转发流程。</span><br>    <span class="hljs-comment">// 意味着子类没有对应的方法实现时</span><br>    <span class="hljs-comment">// 会沿着继承链去尝试调用父类上的 initialize 方法</span><br>    ((<span class="hljs-keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, <span class="hljs-keyword">@selector</span>(initialize));<br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>完成初始化：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lockAndFinishInitializing(Class cls, Class supercls)<br>&#123;<br>    monitor_locker_t lock(classInitLock);<br>    <span class="hljs-keyword">if</span> (!supercls  ||  supercls-&gt;isInitialized()) &#123;<br>        _finishInitializing(cls, supercls);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果父类未被初始化，会在父类初始化完成后再修改当前 cls 初始化状态标记位</span><br>        _finishInitializingAfter(cls, supercls);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>数据结构 <code>PendingInitializeMap</code>:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> PendingInitialize &#123;<br>    Class subclass;<br>    <span class="hljs-keyword">struct</span> PendingInitialize *next;<br><br>    PendingInitialize(Class cls) : subclass(cls), next(nullptr) &#123; &#125;<br>&#125; PendingInitialize;<br><br><span class="hljs-keyword">typedef</span> objc::DenseMap&lt;Class, PendingInitialize *&gt; PendingInitializeMap;<br><span class="hljs-keyword">static</span> PendingInitializeMap *pendingInitializeMap;<br></code></pre></td></tr></table></figure><p><code>pendingInitializeMap</code> 是一个全局的字典结构，它负责维护 <code>+initialize</code> 调用的依赖，会在两个地方访问：</p><ol><li><p>父类未完成初始化时。父类的初始化会优先于当前类，这一设定是通过 <code>_finishInitializingAfter</code> 中如下的关键代码保证的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">PendingInitialize *pending = new PendingInitialize&#123;cls&#125;;<br>auto result = pendingInitializeMap-&gt;try_emplace(supercls, \<br>pending);<br><span class="hljs-keyword">if</span> (!result.second) &#123;<br>    pending-&gt;next = result.first-&gt;second;<br>    result.first-&gt;second = pending;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>父类已经初始化完成时，调用 <code>_finishInitializing</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _finishInitializing(Class cls, Class supercls)<br>&#123;<br>    PendingInitialize *pending;<br><br>    classInitLock.assertLocked();<br>    ASSERT(!supercls  ||  supercls-&gt;isInitialized());<br><br>    <span class="hljs-keyword">if</span> (PrintInitializing) &#123;<br>        _objc_inform(<span class="hljs-string">&quot;INITIALIZE: thread %p: %s is \</span><br><span class="hljs-string">                    fully +initialized&quot;</span>,<br>                    objc_thread_self(), cls-&gt;nameForLogging());<br>    &#125;<br><br>    <span class="hljs-comment">// mark this class as fully +initialized</span><br>    cls-&gt;setInitialized();<br>    classInitLock.notifyAll();<br>    _setThisThreadIsNotInitializingClass(cls);<br>    <br>    <span class="hljs-keyword">if</span> (!pendingInitializeMap) <span class="hljs-keyword">return</span>;<br><br>    auto it = pendingInitializeMap-&gt;find(cls);<br>    <span class="hljs-keyword">if</span> (it == pendingInitializeMap-&gt;end()) <span class="hljs-keyword">return</span>;<br><br>    pending = it-&gt;second;<br>    pendingInitializeMap-&gt;erase(it);<br><br>    <span class="hljs-keyword">if</span> (pendingInitializeMap-&gt;size() == <span class="hljs-number">0</span>) &#123;<br>        delete pendingInitializeMap;<br>        pendingInitializeMap = <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (pending) &#123;<br>        PendingInitialize *next = pending-&gt;next;<br>        <span class="hljs-keyword">if</span> (pending-&gt;subclass) <br>            _finishInitializing(pending-&gt;subclass, cls);<br>        delete pending;<br>        pending = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>_finishInitializing</code> 函数中，设置 <code>RW_INITIALIZED</code> 标记并清除之前设置的 <code>RW_INITIALIZING</code>，设置当前类不再被当前线程独占，然后递归地将先前被阻塞的子类设置为初始化完成状态，由于初始化工作已完成，这里还清理了不再需要的内存占用</p></li></ol></li><li><p>在类初始化未完成之前（<code>RW_INITIALIZING</code>），后续在该线程上其他的 <code>+initialize</code> 调用都会被直接 <code>return</code>；在类已经完成初始化时（<code>RW_INITIALIZED</code>）直接 <code>return</code>，官方的注释也很详细：</p><details><summary>查看官方注释</summary><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (...) &#123;...&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cls-&gt;isInitializing()) &#123;<br>    <span class="hljs-comment">// We couldn&#x27;t set INITIALIZING because INITIALIZING was already set.</span><br>    <span class="hljs-comment">// If this thread set it earlier, continue normally.</span><br>    <span class="hljs-comment">// If some other thread set it, block until initialize is done.</span><br>    <span class="hljs-comment">// It&#x27;s ok if INITIALIZING changes to INITIALIZED while we&#x27;re here, </span><br>    <span class="hljs-comment">//   because we safely check for INITIALIZED inside the lock </span><br>    <span class="hljs-comment">//   before blocking.</span><br>    <span class="hljs-keyword">if</span> (_thisThreadIsInitializingClass(cls)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!MultithreadedForkChild) &#123;<br>        waitForInitializeToComplete(cls);<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// We&#x27;re on the child side of fork(), facing a class that</span><br>        <span class="hljs-comment">// was initializing by some other thread when fork() was called.</span><br>        _setThisThreadIsInitializingClass(cls);<br>        performForkChildInitialize(cls, supercls);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cls-&gt;isInitialized()) &#123;<br>    <span class="hljs-comment">// Set CLS_INITIALIZING failed because someone else already </span><br>    <span class="hljs-comment">//   initialized the class. Continue normally.</span><br>    <span class="hljs-comment">// NOTE this check must come AFTER the ISINITIALIZING case.</span><br>    <span class="hljs-comment">// Otherwise: Another thread is initializing this class. ISINITIALIZED </span><br>    <span class="hljs-comment">//   is false. Skip this clause. Then the other thread finishes </span><br>    <span class="hljs-comment">//   initialization and sets INITIALIZING=no and INITIALIZED=yes. </span><br>    <span class="hljs-comment">//   Skip the ISINITIALIZING clause. Die horribly.</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details></li></ul></li><li>到这里已经梳理完了类的 <code>+initialize</code> 调用流程，验证了苹果 API 文档中关于 <code>+initialize</code> 的特性</li></ol><h2 id="load"><a href="#load" class="headerlink" title="load"></a><code>load</code></h2><blockquote><p><code>load</code> 方法相信都不陌生，用得最多的场景就是方法交换，而且大家也都知道 <code>load</code> 方法会先于 <code>main</code> 函数调用。接下来将对照源码来理解 <code>load</code> 方法具体的调用过程。</p></blockquote><p>还是刚刚的<a target="_blank" rel="noopener" href="https://github.com/Navimark/RuntimeLoadInit">四世同堂工程</a>，添加符号断点 <code>+[KFCRootObject load]</code>，运行后的调用栈为：<br><img src="fc800951/7.png" srcset="/img/loading.gif" lazyload alt=""><br>还是按照入栈顺序分析：</p><ol><li><p><code>_dyld_start</code>-&gt;<code>dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)</code> -&gt; <code>load_images</code>，前两个栈记录是操作系统通过 <code>dyld</code> 加载程序时，<code>dyld</code> 的内部函数调用过程，<code>dyld</code> 负责给程序创建一个和操作系统绑定的运行环境，包括链接程序所用到的动态库（包括系统动态库）、绑定外部调用符号、rebase 基址，做完了环境准备工作后，通过 <code>load_images</code> 回调 runtime。我们增加一个符号断点：<code>load_images</code>，重新 run 起来：<br><img src="fc800951/8.png" srcset="/img/loading.gif" lazyload alt=""></p><p>定位到 <code>_objc_init</code> 的源码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> _objc_init(<span class="hljs-keyword">void</span>)<br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> initialized = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (initialized) <span class="hljs-keyword">return</span>;<br>    initialized = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-comment">// fixme defer initialization until an objc-using image is found?</span><br>    environ_init();<br>    tls_init();<br>    static_init();<br>    runtime_init();<br>    exception_init();<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __OBJC2__</span><br>    cache_t::init();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    _imp_implementationWithBlock_init();<br><br>    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __OBJC2__</span><br>    didCallDyldNotifyRegister = <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>链接库被初始化之前 <code>libSystem</code> 调用 <code>_objc_init</code> 进行初始化，在 <code>_objc_init</code> 中又通过 <code>_dyld_objc_notify_register</code> 注册了 <code>dyld</code> 的回调，在 <code>dyld</code> <a target="_blank" rel="noopener" href="https://opensource.apple.com/source/dyld/dyld-832.7.1/include/mach-o/dyld_priv.h.auto.html">源码</a><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="找到对应版本的 dyld 源码：输入 lldb 命令：image list dyld，得到dyld所在路径为：/usr/lib/dyld，使用 MachOView 打开，在 LoadCommand 的 LC_SOURCE_VERSION 中找到源码 Version ，我这里是 832.7.1
">[4]</span></a></sup> 中可以查看到 <code>_dyld_objc_notify_register</code> 的原型：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,<br>                                _dyld_objc_notify_init      init,<br>                                _dyld_objc_notify_unmapped  unmapped);<br></code></pre></td></tr></table></figure><p>通过注释可知，当某个镜像将被 <code>dyld</code> 初始化时，<code>dyld</code> 会通过 <code>init</code> 这个函数指针形参将该镜像信息回调给 objc runtime。来看看 <code>load_images</code>:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> load_images(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path __unused, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> mach_header *mh)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;<br>        didInitialAttachCategories = <span class="hljs-literal">true</span>;<br>        loadAllCategories();<br>    &#125;<br><br>    <span class="hljs-comment">// Return without taking locks if there are no +load methods here.</span><br>    <span class="hljs-keyword">if</span> (!hasLoadMethods((<span class="hljs-keyword">const</span> headerType *)mh)) <span class="hljs-keyword">return</span>;<br><br>    recursive_mutex_locker_t lock(loadMethodLock);<br><br>    <span class="hljs-comment">// Discover load methods</span><br>    &#123;<br>        mutex_locker_t lock2(runtimeLock);<br>        prepare_load_methods((<span class="hljs-keyword">const</span> headerType *)mh);<br>    &#125;<br><br>    <span class="hljs-comment">// Call +load methods (without runtimeLock - re-entrant)</span><br>    call_load_methods();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>遍历所有链接进来的 Image 头信息链表，找到所有的 Category 方法，并附加到对应的类的方法列表上</li><li>通过查询 Image 的 Mach-O 结构，在 <code>__DATA,__objc_nlclslist</code> 和 <code>__DATA,__objc_nlcatlist</code> 中分别检查是否存在包含 <code>+load</code> 方法的类和包含 <code>+load</code> 方法的分类， 如果没有，跳过 <code>load_images</code> 接下来的步骤</li><li>准备 load 方法。先通过 <code>_getObjc2NonlazyClassList</code> 获取到所有包含 <code>+load</code> 的类（话说这里分别进行了两次重复的 Mach-O 结构的查找，也许可以合并为一次🤔），然后将这些类添加到 <code>loadable_classes</code> 数组中。如果某个类有父类，父类的 load 方法（如果有）将会先添加到 <code>loadable_classes</code> 里面，这是通过 <code>schedule_class_load</code> 的递归调用保证的。接下来对包含 <code>+load</code> 的分类进行类似的操作，将结果保存在 <code>loadable_categories</code> 数组中。</li><li>调用 <code>call_load_methods</code>，执行 +load 方法。<code>call_load_methods</code> 可能会触发其他镜像的映射(mapping)，其他的镜像映射时可能会有它自己的 <code>+load</code> 调用过程，所以 <code>call_load_methods</code> 可能会发生 Re-entrant。当 Re-entrant 发生时啥也不用做，因为按照我们刚刚的分析，其他镜像加载时执行到 <code>call_load_methods</code> 时，所包含 <code>+load</code> 方法的类和分类已经被添加到了全局的 <code>loadable_classes</code> 和 <code>loadable_categories</code> 中。</li><li>先开启一个 <code>autoreleasepool</code>，接下来会先在一个循环中不断调用先前找到的类的 <code>+load</code> 方法，且保证在一个镜像中，本类的 <code>+load</code> 总是比分类的 <code>+load</code> 先调用</li><li><code>call_class_loads</code> 方法，涉及到一个比较有意思的任务控制。先前我们知道 <code>loadable_classes</code> 数组保存的是 <code>struct loadable_class</code> 结构体，它指向通过 <code>realloc</code> 申请到的内存，在 <code>call_class_loads</code> 中首先用一个临时指针指向该内存区间，然后重置 <code>loadable_classes</code> 相关的全局变量，后续如果其他的 Image 被加载导致 <code>add_class_to_loadable_list</code> 被调用时 <code>loadable_classes</code> 数组会指向重新申请的内存空间，<code>+load</code> 方法会被继续添加到这个数组里面，视 <code>call_class_loads</code> 消耗的速度，<code>loadable_classes</code> 可能是重新申请内存(<code>loadable_classes == NULL</code> 时)，也可能是在原有内存区域扩大空间，这些堆空间最终都会在 <code>call_class_loads</code> 中被 <code>free</code>。回到 <code>call_class_loads</code> 函数，它顺序遍历上述临时指针指向的数组，取出 <code>load_method_t</code> 进行 <code>+load</code> 调用（注意是通过函数地址直接调用，没有走 <code>objc_msgSend</code> 流程），由于该数组中父类的 <code>+load</code> 在前面，所以父类的 <code>+load</code> 方法会被先调用</li><li>对分类的 <code>+load</code> 方法收集和本类的差不多，但是当分类的 Image 在本类的 Image 之前被加载运行时，存在额外的处理流程，所以分类的 <code>+load</code> 调用逻辑会有所不同。先遍历<code>loadable_categories</code>，如果类被首次加载过（Realized）就调用其 <code>+load</code> 方法，然后将该分类的从数组中移除，同时会将 Re-entrant 过程新增加的分类整理到一起，最后如果 <code>loadable_categories_used</code> 不为 0，返回 <code>true</code>，以便在 <code>call_load_methods</code> 中能够通过循环继续处理本次未处理完毕的分类 <code>+load</code> 方法</li></ol></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们通过源码分析 <code>+load</code> 和 <code>+initialize</code> 的调用时机以及它们各自的调用特点，总结如下：</p><ul><li><p><code>+load</code></p><ol><li>类的 <code>+load</code> 方法一定会被调用，而且是在 <code>+main</code> 函数之前被调用</li><li>父类的 <code>+load</code> 方法一定会先于子类的 <code>+load</code> 方法调用，而且在子类的 <code>+load</code> 中不需要添加 <code>[super load];</code></li><li>类的 <code>+load</code> 方法会先于分类的 <code>+load</code> 方法调用</li><li>由于动态链接库先于主程序二进制加载，所以动态链接库里面的 <code>+load</code> 方法会先于主程序的 <code>+load</code> 方法调用</li></ol></li><li><code>+initialize</code><ol><li><code>+initialize</code> 会在类首次收到消息之前调用</li><li>父类的 <code>+initialize</code> 会优先于子类的 <code>+initialize</code> 调用</li><li>runtime 会自动处理对继承链上的 <code>+initialize</code> 调用，所以重写时无需调用 <code>[super initialize];</code></li><li>相对于 <code>+load</code> ，<code>+initialize</code> 是普通方法，可以被交换；在多个分类中被实现时只会调用 Complie Sources 列表中最靠后的分类中的那个</li></ol></li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://github.com/LGCooci/objc4_debug/tree/master/objc4-818.2">https://github.com/LGCooci/objc4_debug/tree/master/objc4-818.2</a> <a href="#fnref:1" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>尝试过在 <code>KFCRootObject.m</code> 的 <code>+ (void)initialize</code> 处添加断点，但运行时没有进来🤔，知道原因的大佬烦请留言赐教 <a href="#fnref:2" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>x86_64 架构运行 <a href="#fnref:3" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>找到对应版本的 <code>dyld</code> 源码：输入 <code>lldb</code> 命令：<code>image list dyld</code>，得到<code>dyld</code>所在路径为：<code>/usr/lib/dyld</code>，使用 MachOView 打开，在 LoadCommand 的 LC_SOURCE_VERSION 中找到源码 Version ，我这里是 <code>832.7.1</code> <a href="#fnref:4" rev="footnote" class="footnote-backref">↩</a></span></span></li></ol></div></section></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E5%BA%95%E5%B1%82/">底层</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/%E5%BA%95%E5%B1%82/">底层</a> <a class="hover-with-bg" href="/tags/iOS/">iOS</a> <a class="hover-with-bg" href="/tags/Runtime/">Runtime</a> <a class="hover-with-bg" href="/tags/Objective-C/">Objective-C</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/posts/d463489f.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">使用 Xcode 编译规则提升代码质量</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/4b4dbb8b.html"><span class="hidden-mobile">给 Xcode 工程的 AppIcon 添加版本信息</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",(function(){var i=Object.assign({appId:"wphA3YWunUyu9a9gbGyb9kh1-MdYXbMMI",appKey:"Y6tve5P6QYMvu13i6cXcL8ly",path:"window.location.pathname",placeholder:"说点什么",avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!1,serverURLs:null,emojiCDN:null,emojiMaps:null,enableQQ:!1,appid:"wphA3YWunUyu9a9gbGyb9kh1-MdYXbMMI",appkey:"Y6tve5P6QYMvu13i6cXcL8ly"},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{Fluid.plugins.initFancyBox("#valine .vcontent img:not(.vemoji)")})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><span id="cnzz_stat_icon_1278975811" style="display:none"></span></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/local-search.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?15186363";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script defer>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-154660540-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script defer src="//s4.cnzz.com/z_stat.php?id=1278975811&show=pic" type="text/javascript"></script><script src="/js/boot.js"></script></body></html>